@import "base/memory.imp";
@import "stdio.h";

struct[T] result: {
    $T value;
    bool error;
}

result(typeid T result[T] res) result_unwrap: {
    if (res.error) {
        @c [exit(1);];
    }

    return res.value;
}

struct[T] dyn: {
    ^$T data;
    usize len;
    usize cap;
}

dyn(typeid T) dyn_new: {
    dyn[T] new;
    new.len: 0;
    new.cap: 32;
    @c [new.data = alloc(new.cap, sizeof(T));];
    @c [if (new.data == NULL) exit(1);];
    return new;
}

_(typeid T dyn[T] arr $T elem) dyn_push: {
    if ([arr.len + 1] >= arr.cap) {
        arr.cap: [arr.cap + [arr.len + 1] * 2];
        @c [arr.data = re_alloc(arr.data, arr.cap * sizeof(T));];
    }

    arr.data[arr.len]: elem;
    arr.len: [arr.len + 1];
}

result(typeid T dyn[T] arr usize index) dyn_at: {
    result[T] ret;
    ret.error: false;

    if (index >= arr.len) {
        ret.error: true;
        return ret;
    }

    ret.value: arr.data[index];
    return ret;
}

_(typeid T dyn[T] arr) dyn_clear: {
    free_mem(arr.data);
    arr: dyn_new(T);
}

_() main: {
    result[int] zeroth_res;
    dyn[int] nums: dyn_new(int);
    dyn_push(int nums 10);
    zeroth_res: dyn_at(int nums 0);

    int zeroth: result_unwrap(int zeroth_res);
    @c [printf("%d\n", zeroth);];
}

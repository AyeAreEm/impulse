@import "math.h";
@import "base/string.imp";

f64 pi :: 3.14159265358979323846;

@inline f32 sine_f32 :: (f32 x) { @c [return sinf(x);]; }
@inline f64 sine_f64 :: (f64 x) { @c [return sin(x);]; }

$T sine :: (typeid T $T x) {
    $T result;
    ^char type: type_to_cstr(T);
    ^char f32_str: type_to_cstr(f32);
    ^char f64_str: type_to_cstr(f64);
    if (cstr.compare(type f32_str)) {
        result: sine_f32(x);
    } orif (cstr.compare(type f64_str)) {
        result: sine_f64(x);
    } else {
        println("type %s can't be used in sine function as it's not a decimal" type_to_cstr(T));
        exitcode(1);
    }
    return result;
}

@inline f32 cosine_f32 :: (f32 x) { @c [return cosf(x);]; }
@inline f64 cosine_f64 :: (f64 x) { @c [return cos(x);]; }

$T cosine :: (typeid T $T x) {
    $T result;
    ^char type: type_to_cstr(T);
    ^char f32_str: type_to_cstr(f32);
    ^char f64_str: type_to_cstr(f64);
    if (cstr.compare(type f32_str)) {
        result: cosine_f32(x);
    } orif (cstr.compare(type f64_str)) {
        result: cosine_f64(x);
    } else {
        println("type %s can't be used in cosine function as it's not a decimal" type_to_cstr(T));
        exitcode(1);
    }
    return result;
}

@inline f32 sqrt_f32 :: (f32 x) { @c [return sqrtf(x);]; }
@inline f64 sqrt_f64 :: (f64 x) { @c [return sqrt(x);]; }

$T square_rt :: (typeid T $T x) {
    $T result;
    ^char type: type_to_cstr(T);
    ^char f32_str: type_to_cstr(f32);
    ^char f64_str: type_to_cstr(f64);
    if (cstr.compare(type f32_str)) {
        result: sqrt_f32(x);
    } orif (cstr.compare(type f64_str)) {
        result: sqrt_f64(x);
    } else {
        println("type %s can't be used in square_rt function as it's not a decimal" type_to_cstr(T));
        exitcode(1);
    }
    return result;
}

@inline f32 power_f32 :: (f32 x f32 y) { @c [return powf(x, y);]; }
@inline f64 power_f64 :: (f64 x f64 y) { @c [return pow(x, y);]; }

$T power :: (typeid T $T x $T y) {
    $T result;
    ^char type: type_to_cstr(T);
    ^char f32_str: type_to_cstr(f32);
    ^char f64_str: type_to_cstr(f64);
    if (cstr.compare(type f32_str)) {
        result: power_f32(x y);
    } orif (cstr.compare(type f64_str)) {
        result: power_f64(x y);
    } else {
        println("type %s can't be used in power function as it's not a decimal" type_to_cstr(T));
        exitcode(1);
    }
    return result;
}

struct Vector2f32 :: {
    f32 x;
    f32 y;

    @inline Vector2f32 new :: (f32 x f32 y) {
        Vector2f32 new;
        new.x: x;
        new.y: y;
        return new;
    }

    @inline Vector2f32 add :: (Vector2f32 a Vector2f32 b) {
        Vector2f32 c;
        c.x: [a.x + b.x];
        c.y: [a.y + b.y];
        return c;
    }

    @inline Vector2f32 sub :: (Vector2f32 a Vector2f32 b) {
        Vector2f32 c;
        c.x: [a.x - b.x];
        c.y: [a.y - b.y];
        return c;
    }

    @inline Vector2f32 mul :: (Vector2f32 a Vector2f32 b) {
        Vector2f32 c;
        c.x: [a.x * b.x];
        c.y: [a.y * b.y];
        return c;
    }

    @inline Vector2f32 div :: (Vector2f32 a Vector2f32 b) {
        Vector2f32 c;
        c.x: [a.x / b.x];
        c.y: [a.y / b.y];
        return c;
    }

    @inline Vector2f32 normalise :: (Vector2f32 vec) {
        f32 mag: square_rt(f32 [vec.x * vec.x + vec.y * vec.y]);
        if (mag > 0) {
            Vector2f32 normalised;
            normalised.x: [vec.x / mag];
            normalised.y: [vec.y / mag];
            return normalised;
        }

        return vec;
    }
}

struct Vector3f32 :: {
    f32 x;
    f32 y;
    f32 z;

    @inline Vector3f32 add :: (Vector3f32 a Vector3f32 b) {
        Vector3f32 c;
        c.x: [a.x + b.x];
        c.y: [a.y + b.y];
        c.z: [a.z + b.z];
        return c;
    }

    @inline Vector3f32 sub :: (Vector3f32 a Vector3f32 b) {
        Vector3f32 c;
        c.x: [a.x - b.x];
        c.y: [a.y - b.y];
        c.z: [a.z - b.z];
        return c;
    }

    @inline Vector3f32 mul :: (Vector3f32 a Vector3f32 b) {
        Vector3f32 c;
        c.x: [a.x * b.x];
        c.y: [a.y * b.y];
        c.z: [a.z * b.z];
        return c;
    }

    @inline Vector3f32 div :: (Vector3f32 a Vector3f32 b) {
        Vector3f32 c;
        c.x: [a.x / b.x];
        c.y: [a.y / b.y];
        c.z: [a.z / b.z];
        return c;
    }
}

struct Vector4f32 :: {
    f32 x;
    f32 y;
    f32 z;
    f32 w;

    @inline Vector4f32 add :: (Vector4f32 a Vector4f32 b) {
        Vector4f32 c;
        c.x: [a.x + b.x];
        c.y: [a.y + b.y];
        c.z: [a.z + b.z];
        c.w: [a.w + b.w];
        return c;
    }

    @inline Vector4f32 sub :: (Vector4f32 a Vector4f32 b) {
        Vector4f32 c;
        c.x: [a.x - b.x];
        c.y: [a.y - b.y];
        c.z: [a.z - b.z];
        c.w: [a.w - b.w];
        return c;
    }

    @inline Vector4f32 mul :: (Vector4f32 a Vector4f32 b) {
        Vector4f32 c;
        c.x: [a.x * b.x];
        c.y: [a.y * b.y];
        c.z: [a.z * b.z];
        c.w: [a.w * b.w];
        return c;
    }

    @inline Vector4f32 div :: (Vector4f32 a Vector4f32 b) {
        Vector4f32 c;
        c.x: [a.x / b.x];
        c.y: [a.y / b.y];
        c.z: [a.z / b.z];
        c.w: [a.w / b.w];
        return c;
    }
}

typeid Quaternionf32 :: Vector4f32;

struct Matrix4x4f32 :: {
    f32 m0; f32 m4; f32 m8; f32 m12;
    f32 m1; f32 m5; f32 m9; f32 m13;
    f32 m2; f32 m6; f32 m10; f32 m14;
    f32 m3; f32 m7; f32 m11; f32 m15;
}

struct Vector2f64 :: {
    f64 x;
    f64 y;

    @inline Vector2f64 add :: (Vector2f64 a Vector2f64 b) {
        Vector2f64 c;
        c.x: [a.x + b.x];
        c.y: [a.y + b.y];
        return c;
    }

    @inline Vector2f64 sub :: (Vector2f64 a Vector2f64 b) {
        Vector2f64 c;
        c.x: [a.x - b.x];
        c.y: [a.y - b.y];
        return c;
    }

    @inline Vector2f64 mul :: (Vector2f64 a Vector2f64 b) {
        Vector2f64 c;
        c.x: [a.x * b.x];
        c.y: [a.y * b.y];
        return c;
    }

    @inline Vector2f64 div :: (Vector2f64 a Vector2f64 b) {
        Vector2f64 c;
        c.x: [a.x / b.x];
        c.y: [a.y / b.y];
        return c;
    }
}

struct Vector3f64 :: {
    f64 x;
    f64 y;
    f64 z;

    @inline Vector3f64 add :: (Vector3f64 a Vector3f64 b) {
        Vector3f64 c;
        c.x: [a.x + b.x];
        c.y: [a.y + b.y];
        c.z: [a.z + b.z];
        return c;
    }

    @inline Vector3f64 sub :: (Vector3f64 a Vector3f64 b) {
        Vector3f64 c;
        c.x: [a.x - b.x];
        c.y: [a.y - b.y];
        c.z: [a.z - b.z];
        return c;
    }

    @inline Vector3f64 mul :: (Vector3f64 a Vector3f64 b) {
        Vector3f64 c;
        c.x: [a.x * b.x];
        c.y: [a.y * b.y];
        c.z: [a.z * b.z];
        return c;
    }

    @inline Vector3f64 div :: (Vector3f64 a Vector3f64 b) {
        Vector3f64 c;
        c.x: [a.x / b.x];
        c.y: [a.y / b.y];
        c.z: [a.z / b.z];
        return c;
    }
}

struct Vector4f64 :: {
    f64 x;
    f64 y;
    f64 z;
    f64 w;

    @inline Vector4f64 add :: (Vector4f64 a Vector4f64 b) {
        Vector4f64 c;
        c.x: [a.x + b.x];
        c.y: [a.y + b.y];
        c.z: [a.z + b.z];
        c.w: [a.w + b.w];
        return c;
    }

    @inline Vector4f64 sub :: (Vector4f64 a Vector4f64 b) {
        Vector4f64 c;
        c.x: [a.x - b.x];
        c.y: [a.y - b.y];
        c.z: [a.z - b.z];
        c.w: [a.w - b.w];
        return c;
    }

    @inline Vector4f64 mul :: (Vector4f64 a Vector4f64 b) {
        Vector4f64 c;
        c.x: [a.x * b.x];
        c.y: [a.y * b.y];
        c.z: [a.z * b.z];
        c.w: [a.w * b.w];
        return c;
    }

    @inline Vector4f64 div :: (Vector4f64 a Vector4f64 b) {
        Vector4f64 c;
        c.x: [a.x / b.x];
        c.y: [a.y / b.y];
        c.z: [a.z / b.z];
        c.w: [a.w / b.w];
        return c;
    }
}

typeid Quaternionf64 :: Vector4f64;

struct Matrix4x4f64 :: {
    f64 m0; f64 m4; f64 m8; f64 m12;
    f64 m1; f64 m5; f64 m9; f64 m13;
    f64 m2; f64 m6; f64 m10; f64 m14;
    f64 m3; f64 m7; f64 m11; f64 m15;
}

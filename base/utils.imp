@import "stdio.h";
@import "stdlib.h";

@inline _ exitcode :: (int code) {
    @c [exit(code);];
}

struct[T] option :: {
    $T value;
    bool none;

    option[T] unwrap :: (typeid T option[T] opt) {
        if (opt.none) {
            @c [fprintf(stderr, "error: failed to unwrap in %s:%d\n", __FILE__, __LINE__);];
            @c [fprintf(stderr, "error: please take a look at the c file for more info\n");];
            exitcode(1);
        }
        return opt.value;
    }
}

struct[T] array :: {
    ^$T data;
    usize len;
}

# typeid already makes this inlined but explicity is nice
@inline usize size_of :: (typeid T) {
    @c [sizeof(T);];
}

@inline ^char type_of :: (typeid T) {
    @c [#T;];
}

@inline $T cast_prim :: (typeid T any val) {
    @c [(T)val;];
}

@inline $T cast_struct :: (typeid T any val) {
    @c [*(T*)&val;];
}

# these are only here to claim the definition, this function is made in the compiler
_ print :: () {}
_ println :: () {}

_ panic :: (^char msg) {
    @c [fprintf(stderr, "panic at %s:%d\n", __FILE__, __LINE__);];
    println("%s" msg);
    exitcode(1);
}

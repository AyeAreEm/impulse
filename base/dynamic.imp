@import "base/memory.imp";

struct[T] dyn :: {
    ^$T data;
    usize len;
    usize cap;

    dyn[T] new :: (typeid T) {
        dyn[T] new;
        new.len: 0;
        new.cap: 32;
        new.data: mem.alloc(T new.cap);
        @c [ 
            if (new.data == NULL) {
                fprintf(stderr, "error: failed to allocate memory in %s at line %d\n", __FILE__, __LINE__);
                fprintf(stderr, "error: please take a look at the c file for more info\n");
                exit(1);
            }
         ];
        return new;
    }

    option[T] at :: (typeid T dyn[T] arr usize index) {
        option[T] ret;
        ret.none: false;

        if (index >= arr.len) {
            ret.none: true;
            return ret;
        }

        ret.value: arr.data[index];
        return ret;
    }

    _ push :: (typeid T dyn[T] arr $T elem) {
        if ([arr.len + 1] >= arr.cap) {
            arr.cap: [[arr.cap + arr.len + 1] * 2];
            @c [arr.data = realloc(arr.data, arr.cap * sizeof(T));];
        }

        arr.data[arr.len]: elem;
        arr.len: [arr.len + 1];
    }

    _ clear :: (typeid T dyn[T] arr) {
        mem.dealloc(arr.data);
        arr: dyn.new(T);
    }

    _ remove :: (typeid T dyn[T] arr usize index) {
        @c [mem__move(&arr.data[index], &arr.data[index + 1], (arr.len - index - 1) * sizeof(T));];
        arr.len: [arr.len - 1];
    }
}

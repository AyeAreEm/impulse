# Dynamic array library
@import "base/memory.imp";

struct[T] dyn :: {
    ^$T data;
    usize len; 
    usize cap;  # cap in number of elements, NOT number of bytes

    dyn[T] new :: (typeid T) {
        dyn[T] arr;
        arr.len: 0;
        arr.cap: 32;
        arr.data: mem.alloc(T arr.cap);
        @c [ 
            if (arr.data == NULL) {
                panic("failed to allocate memory");
                exit(1);
            }
         ];
        return arr;
    }

    # new dyn with a set capacity
    dyn[T] with_capacity :: (typeid T usize cap) {
        dyn[T] arr;

        if (cap > 32) {
            arr.cap: cap;
        } else {
            arr.cap: 32;
        }
        arr.len: 0;
        arr.data: mem.alloc(T arr.cap);
        @c [
            if (arr.data == NULL) {
                panic("failed to allocate memory");
                exit(1);
            }
        ];
        return arr;
    }

    dyn[T] clone :: (typeid T dyn[T] src) {
        let dest: dyn.with_capacity(T src.cap);
        dest.len: src.len;

        mem.copy(dest.data src.data dest.cap);
        @c [
            if (dest.data == NULL) {
                panic("failed to allocate memory");
                exit(1);
            }
        ];
        return dest;
    }

    _ resize :: (typeid T ^dyn[T] arr) {
        @mut arr;

        arr.cap: [arr.cap * 2];
        usize T_size :: @c [sizeof(T);];
        arr.data: mem.realloc(arr.data [T_size * arr.cap]);
        @c [
            if (arr->data == NULL) {
                panic("failed to reallocate memory");
                exit(1);
            }
        ];
    }

    _ resize_with_size :: (typeid T ^dyn[T] self usize size) {
        @mut self;

        self.cap: [self.cap * 2 + size];
        usize T_size :: @c [sizeof(T);];
        self.data: mem.realloc(self.data [T_size * self.cap]);
        @c [
            if (self->data == NULL) {
                panic("failed to allocate memory");
                exit(1);
            }
        ];
    }

    # get elemet at index
    option[T] at :: (typeid T dyn[T] arr usize index) {
        option[T] ret;

        if (index >= arr.len) {
            ret.none: true;
            return ret;
        }

        ret.value: arr.data[index];
        return ret;
    }

    _ replace :: (typeid T ^dyn[T] self usize index $T elem) {
        @mut self;
        if (index >= self.cap) {
            panic("index out of capacity bounds");
        }

        self.data[index]: elem;
    }

    _ push :: (typeid T ^dyn[T] arr $T elem) {
        @mut arr;

        if ([arr.len + 1] >= arr.cap) {
            dyn.resize(T arr);
        }

        dyn.replace(T arr arr.len elem);
        arr.len: [arr.len + 1];
    }

    option[T] pop :: (typeid T ^dyn[T] arr) {
        @mut arr;

        let deref_arr: arr^;
        let ret: dyn.at(T deref_arr [arr.len - 1]);
        if (ret) [_] {
            arr.len: [arr.len - 1];
        }
        return ret;
    }

    # data is still there, just not available since len is 0
    _ clear :: (typeid T ^dyn[T] arr) {
        @mut arr;
        arr.len: 0;
    }

    # returns true if successfully removed
    bool remove :: (typeid T ^dyn[T] arr usize index) {
        @mut arr;

        let deref_arr: arr^;
        let has_index: dyn.at(T deref_arr index);
        if (has_index) [_] {
            @c [mem__move(&arr->data[index], &arr->data[index + 1], (arr->len - index - 1) * sizeof(T));];
            arr.len: [arr.len - 1];
            return true;
        }

        return false;
    }

    _ dealloc :: (typeid T ^dyn[T] arr) {
        @mut arr;

        arr.len: 0;
        arr.cap: 0;
        mem.dealloc(arr.data);
    }
}

@import "stdio.h";
@import "stdlib.h";

@inline _ exitcode :: (int code) {
    @c [exit(code);];
}

struct[T] option :: {
    $T value;
    bool none;

    option[T] unwrap :: (typeid T option[T] opt) {
        if (opt.none) {
            @c [fprintf(stderr, "error: failed to unwrap in %s:%d\n", __FILE__, __LINE__);];
            @c [fprintf(stderr, "error: please take a look at the c file for more info\n");];
            exitcode(1);
        }
        return opt.value;
    }
}

struct[T] array :: {
    ^$T data;
    usize len;
}

# typeid already makes this inlined but explicity is nice
@inline usize size_of :: (typeid T) {
    @c [sizeof(T);];
}

@inline ^char type_of :: (typeid T) {
    @c [#T;];
}

@inline $T cast :: (typeid T any val) {
    @c [*(T*)&val;];
}

# these are only here to claim the definition, this function is made in the compiler
_ print :: () {}
_ println :: () {}

_ panic :: (^char msg) {
    @c [fprintf(stderr, "panic at %s:%d: %s\n", __FILE__, __LINE__, msg);];
    exitcode(1);
}

# runtime assert
_ rt_assert :: (bool expression ^char msg) {
    if (expression) {
        return;
    }

    println("assertion failed: %s" msg);
}

# comptime assert
_ ct_assert :: (bool expression ^char msg) {
    # no clue how to do this rn
}

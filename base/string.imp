@import "base/memory.imp";
@import "stdio.h";

struct string :: {
    ^char data;
    usize cap;
    usize len;
}

@inline usize cstr.len(^char str) :: {
    # maybe just write out the code instead of making a function that calls a function
    # func calls are more expensive than rewriting
    @c [return strlen(str);];
}

@inline int cstr.copy(^char dest usize byte_size ^char src) :: {
    # doubt i could write safe code that copies strings
    @c [return strcpy_s(dest, byte_size, src);];
}

string str.new() :: {
    string new;
    new.len: 0;
    new.cap: 50;
    new.data: mem.alloc(char new.cap);
    @c [
        if (new.data == NULL) {
            exit(1);
        }
    ];

    return new;
}

_ str.resize(^string str usize modifier) :: {
    usize increase: [[str.len + modifier] * 2];
    str.cap: [str.cap + increase];

    int new_size: [str.cap + 1];
    str.data: mem.re_alloc(str.data new_size);
}

string str.from(^char str) :: {
    string new: str.new();
    usize cstr_len: cstr.len(str);

    if (cstr_len > new.cap) {
        str.resize(&new cstr_len);
    }

    new.len: cstr_len;
    cstr.copy(new.data [new.cap + 1] str);
    return new;
}

_ str.push(^string str char ch)  :: {
    usize new_len: [str.len + 1];

    if (new_len >= str.cap) {
        str.resize(str 0);
    }

    str.data[str.len]: ch;
    str.len: new_len;
}

bool str.compare(string str1 string str2) :: {
    if (str1.len != str2.len) {
        return false;
    }

    loop (i < str1.len) [+] {
        if (str1.data[i] != str2.data[i]) {
            return false;
        }
    }

    return true;
}

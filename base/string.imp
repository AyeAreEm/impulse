# Memory allocated string with length and null terminated for easy C interopability

@import "base/builtin.imp";
@import "base/memory.imp";

@inline ^char cstr.copy :: (^char dest ^char src usize byte_size) {
    # doubt i could write safe code that copies strings
    @c [ return strncpy(dest, src, byte_size); ];
}

struct string :: {
    ^char data;
    usize cap;
    usize len;
    
    string new :: () {
        string new;
        new.len: 0;
        new.cap: 32; # including null terminator
        new.data: mem.alloc(char new.cap);
        @c [
            if (new.data == NULL) {
                fprintf(stderr, "error: failed to allocate memory in %s at line %d\n", __FILE__, __LINE__);
                fprintf(stderr, "error: please take a look at the c file for more info\n");
                exit(1);
            }
        ];

        return new;
    }

    string with_capacity :: (usize cap) {
        string new;
        new.len: 0;
        new.cap: cap;
        new.data: mem.alloc(char new.cap);
        @c [
            if (new.data == NULL) {
                fprintf(stderr, "error: failed to allocate memory in %s at line %d\n", __FILE__, __LINE__);
                fprintf(stderr, "error: please take a look at the c file for more info\n");
                exit(1);
            }
        ];
        return new;
    }

    _ resize :: (^string str usize modifier) {
        str.cap: [[str.cap + modifier] * 2];
        str.data: mem.realloc(str.data str.cap);
    }

    #_ copy :: (^char dest ^char src usize byte_size) {
    #    cstr.copy(dest src byte_size);
    #    @c [dest[*dest-1] = '\0';];
    #}

    string clone :: (string src) {
        string new: string.with_capacity(src.cap);
        mem.copy(new.data src.data new.cap);
        new.len: src.len;
        @c [new.data[new.len] = '\0';];
        return new;
    }

    string from :: (^char str) {
        string new: string.new();
        usize cstr_len: cstr.len(str);

        if ([cstr_len + 1] >= new.cap) {
            string.resize(&new [cstr_len + 1]);
        }

        new.len: cstr_len;
        mem.copy(new.data str new.cap);

        @c [new.data[new.len] = '\0';];
        return new;
    }

    _ push_char :: (^string str char ch) {
        usize new_len: [str.len + 1];

        if (new_len >= str.cap) {
            string.resize(str 0);
        }

        str.data[str.len]: ch;
        str.len: new_len;
        @c [str->data[new_len] = '\0';];
    }

    _ push_cstr :: (^string dest ^char src) {
        usize src_len: cstr.len(src);
        usize new_len: [dest.len + src_len];

        if ([new_len + 1] >= dest.cap) {
            string.resize(dest [new_len + 1]);
        }

        ^_ end_data: [dest.data + dest.len];
        mem.copy(end_data src src_len);

        dest.len: new_len;
        @c [dest->data[new_len] = '\0';];
    }

    _ push_string :: (^string dest string src) {
        usize new_len :: [dest.len + src.len];

        if ([new_len + 1] >= dest.cap) {
            string.resize(dest [new_len + 1]);
        }

        ^_ end_data: [dest.data + dest.len];
        mem.copy(end_data src.data src.len);

        dest.len: new_len;
        @c [dest->data[new_len] = '\0';];
    }

    _ push_str :: (^string dest str src) {
        usize new_len :: [dest.len + src.len];
        
        if ([new_len + 1] >= dest.cap) {
            string.resize(dest [new_len + 1]);
        }

        ^_ end_data: [dest.data + dest.len];
        mem.copy(end_data src.data src.len);
        
        dest.len: new_len;
        @c [dest->data[new_len] = '\0';];
    }

    _ push :: (^string dest typeid T $T src) {
        ^char type: type_to_cstr(T);
        if (cstr.compare(type "string")) {
            string.push_string(dest cast(string src));
        } orif (cstr.compare(type "char")) {
            string.push_char(dest cast(char src));
        } orif (cstr.compare(type "char*")) {
            string.push_cstr(dest cast(^char src));
        } orif (cstr.compare(type "str")) {
            string.push_str(dest cast(str src));
        } else {
            println("%s is not supported for pushing to a string" type);
            exitcode(1);
        }
    }

    bool compare :: (string first string second) {
        if (first.len != second.len) {
            return false;
        }

        for (first) [ch i] {
            if (ch = second.data[i]) {
                return false;
            }
        }

        return true;
    }

    option[char] at :: (string str usize index) {
        option[char] ret;

        if (index >= str.len) {
            ret.none: true;
            return ret;
        }

        ret.value: str.data[index];
        return ret;
    }

    bool starts_with :: (string str char ch) {
        option[char] first_letter_op: string.at(str 0);
        if (first_letter_op.none) {
            return false;
        }
        if (first_letter_op.value != ch) {
            return false;
        }

        return true;
    }

    bool ends_with :: (string str char ch) {
        option[char] last_letter_op: string.at(str [str.len - 1]);
        if (last_letter_op.none) {
            return false;
        }
        if (last_letter_op.value != ch) {
            return false;
        }
        return true;
    }

    _ to_lowercase :: (string str) {
        for (str) [ch i] {
            @c [str.data[i] = tolower(ch);];
        }
    }
    
    _ to_uppercase :: (string str) {
        for (str) [ch i] {
            @c [str.data[i] = toupper(ch);];
        }
    }

    _ replace_char :: (string str char from char to) {
        for (str) [ch i] {
            if (ch = from) {
                str.data[i]: to;
            }
        }
    }

    bool replace_index :: (str word usize index char to) {
        option[char] at_index: str.at(word index);
        if (at_index.none = true) {
            return false;
        }

        word.data[index]: to;
        return true;
    }

    #bool contains :: (string str ^char pattern) {}
    
    _ dealloc :: (string str) {
        mem.dealloc(str.data);
        str.len: 0;
        str.cap: 0;
    }
}

# this function is handled in the compiler but you can see the code for it below
# returns an empty string if there's an error
_ string.format :: () { }

# string.format();
@c [
string __IMPULSE__STRING__FORMAT__(char* fmt, ...) {
    string result = string__new();

    va_list args;
    va_start(args, fmt);

    int size = vsnprintf(NULL, 0, fmt, args);
    if (size <= 0) {
        va_end(args);
        return result;
    }

    if (size + 1 >= result.cap) {
        string__resize(&result, size + 1);
    }

    vsnprintf(result.data, size, fmt, args);
    va_end(args);

    result.len = size;
    return result;
}
];

# Memory allocated string with length and null terminated for easy C interopability
@import "base/dynamic.imp";

struct string :: {
    dyn[char] buf;

    string new :: () {
        string s;
        s.buf: dyn.new(char);
        return s;
    }

    string with_capacity :: (usize cap) {
        string s;
        s.buf: dyn.with_capacity(char cap);
        return s;
    }

    string clone :: (string src) {
        let new_buf: dyn.clone(char src.buf);
        string dest: |new_buf|;
        return dest;
    }

    _ resize :: (^string self) {
        @mut self;
        dyn.resize(char &self.buf);
    }

    _ resize_with_size :: (^string self usize size) {
        @mut self;
        dyn.resize_with_size(char &self.buf size);
    }

    option[char] at :: (string self usize index) {
        return dyn.at(char self.buf index);
    }

    # replace char at index
    _ replace :: (^string self usize index char to) {
        @mut self;
        dyn.replace(char &self.buf index to);
    }

    _ push_char :: (^string self char ch) {
        @mut self;
        dyn.push(char &self.buf ch);
        string.replace(self self.buf.len 0);
    }

    _ push :: (^string self ^char cstr) {
        @mut self;

        let cstr.len: c.strlen(cstr);
        if ([self.buf.len + cstr.len] >= self.buf.cap) {
            string.resize_with_size(self cstr.len);
        }

        loop (i < cstr.len) [+] {
            char ch: cstr[i];
            string.push_char(self ch);
        }
    }

    string from :: (^char content) {
        let content.len: c.strlen(content);
        string s: string.new();

        loop (i < content.len) [+] {
            char ch: content[i];
            string.push_char(&s ch);
        }
        return s;
    }

    bool compare :: (string first string second) {
        if (first.buf.len != second.buf.len) {
            return false;
        }

        for (first) [ch i] {
            if (ch = second.buf.data[i]) {
                return false;
            }
        }

        return true;
    }

    bool starts_with :: (string self char ch) {
        option[char] first_letter: string.at(self 0);
        if (first_letter) [letter] {
            @c [return letter == ch;];
        }

        return false;
    }

    bool ends_with :: (string self char ch) {
        option[char] last_letter: string.at(self [self.buf.len - 1]);
        if (last_letter) [letter] {
            @c [return letter == ch;];
        }
        return false;
    }

    _ to_lowercase :: (string self) {
        @mut self;

        for (&self) [^ch] {
            ch^: @c [tolower(*ch)];
        }
    }

    _ to_uppercase :: (string self) {
        @mut self;

        for (&self) [^ch] {
            ch^: @c [toupper(*ch)];
        }
    }

    bool contains :: (string self ^char pattern) {
        let pattern.len: c.strlen(pattern);
        usize head: 0;

        if (self.buf.len < pattern.len) {
            return false;
        }

        for (self) [ch] {
            if (head = pattern.len) {
                return true;
            }

            if (ch = pattern[head]) {
                head: [head+1];
            } else {
                head: 0;
            }
        }

        if (head = pattern.len) {
            return true;
        }

        return false;
    }

    _ clear :: (^string self) {
        @mut self;

        dyn.clear(char &self.buf);
    }

    _ remove :: (^string self usize index) {
        @mut self;
        dyn.remove(char &self.buf index);
    }

    _ dealloc :: (^string self) {
        @mut self;
        dyn.dealloc(char &self.buf);
    }
}

# this function is handled in the compiler but you can see the code for it below
# returns an empty string if there's an error
string string.format :: () { }

# string.format();
@c [
string __IMPULSE__STRING__FORMAT__(char* fmt, ...) {
    string result = string__new();

    va_list args;
    va_start(args, fmt);

    int size = vsnprintf(NULL, 0, fmt, args);
    if (size <= 0) {
        va_end(args);
        return result;
    }

    if ((usize)size + 1 >= result.buf.cap) {
        string__resize_with_size(&result, size + 1);
    }

    vsnprintf(result.buf.data, size + 1, fmt, args);
    va_end(args);

    result.buf.len = size;
    return result;
}
];
